{"ast":null,"code":"var JsonWebTokenError = require('./lib/JsonWebTokenError');\nvar NotBeforeError = require('./lib/NotBeforeError');\nvar TokenExpiredError = require('./lib/TokenExpiredError');\nvar decode = require('./decode');\nvar timespan = require('./lib/timespan');\nvar validateAsymmetricKey = require('./lib/validateAsymmetricKey');\nvar PS_SUPPORTED = require('./lib/psSupported');\nvar jws = require('jws');\nvar _require = require(\"crypto\"),\n  KeyObject = _require.KeyObject,\n  createSecretKey = _require.createSecretKey,\n  createPublicKey = _require.createPublicKey;\nvar PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nvar EC_KEY_ALGS = ['ES256', 'ES384', 'ES512'];\nvar RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nvar HS_ALGS = ['HS256', 'HS384', 'HS512'];\nif (PS_SUPPORTED) {\n  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n}\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\n  if (typeof options === 'function' && !callback) {\n    callback = options;\n    options = {};\n  }\n  if (!options) {\n    options = {};\n  }\n\n  //clone this object since we are going to mutate it.\n  options = Object.assign({}, options);\n  var done;\n  if (callback) {\n    done = callback;\n  } else {\n    done = function done(err, data) {\n      if (err) throw err;\n      return data;\n    };\n  }\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\n  }\n  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {\n    return done(new JsonWebTokenError('nonce must be a non-empty string'));\n  }\n  if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean') {\n    return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));\n  }\n  var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n  if (!jwtString) {\n    return done(new JsonWebTokenError('jwt must be provided'));\n  }\n  if (typeof jwtString !== 'string') {\n    return done(new JsonWebTokenError('jwt must be a string'));\n  }\n  var parts = jwtString.split('.');\n  if (parts.length !== 3) {\n    return done(new JsonWebTokenError('jwt malformed'));\n  }\n  var decodedToken;\n  try {\n    decodedToken = decode(jwtString, {\n      complete: true\n    });\n  } catch (err) {\n    return done(err);\n  }\n  if (!decodedToken) {\n    return done(new JsonWebTokenError('invalid token'));\n  }\n  var header = decodedToken.header;\n  var getSecret;\n  if (typeof secretOrPublicKey === 'function') {\n    if (!callback) {\n      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));\n    }\n    getSecret = secretOrPublicKey;\n  } else {\n    getSecret = function getSecret(header, secretCallback) {\n      return secretCallback(null, secretOrPublicKey);\n    };\n  }\n  return getSecret(header, function (err, secretOrPublicKey) {\n    if (err) {\n      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));\n    }\n    var hasSignature = parts[2].trim() !== '';\n    if (!hasSignature && secretOrPublicKey) {\n      return done(new JsonWebTokenError('jwt signature is required'));\n    }\n    if (hasSignature && !secretOrPublicKey) {\n      return done(new JsonWebTokenError('secret or public key must be provided'));\n    }\n    if (!hasSignature && !options.algorithms) {\n      return done(new JsonWebTokenError('please specify \"none\" in \"algorithms\" to verify unsigned tokens'));\n    }\n    if (secretOrPublicKey != null && !(secretOrPublicKey instanceof KeyObject)) {\n      try {\n        secretOrPublicKey = createPublicKey(secretOrPublicKey);\n      } catch (_) {\n        try {\n          secretOrPublicKey = createSecretKey(typeof secretOrPublicKey === 'string' ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);\n        } catch (_) {\n          return done(new JsonWebTokenError('secretOrPublicKey is not valid key material'));\n        }\n      }\n    }\n    if (!options.algorithms) {\n      if (secretOrPublicKey.type === 'secret') {\n        options.algorithms = HS_ALGS;\n      } else if (['rsa', 'rsa-pss'].includes(secretOrPublicKey.asymmetricKeyType)) {\n        options.algorithms = RSA_KEY_ALGS;\n      } else if (secretOrPublicKey.asymmetricKeyType === 'ec') {\n        options.algorithms = EC_KEY_ALGS;\n      } else {\n        options.algorithms = PUB_KEY_ALGS;\n      }\n    }\n    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {\n      return done(new JsonWebTokenError('invalid algorithm'));\n    }\n    if (header.alg.startsWith('HS') && secretOrPublicKey.type !== 'secret') {\n      return done(new JsonWebTokenError(\"secretOrPublicKey must be a symmetric key when using \".concat(header.alg)));\n    } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey.type !== 'public') {\n      return done(new JsonWebTokenError(\"secretOrPublicKey must be an asymmetric key when using \".concat(header.alg)));\n    }\n    if (!options.allowInvalidAsymmetricKeyTypes) {\n      try {\n        validateAsymmetricKey(header.alg, secretOrPublicKey);\n      } catch (e) {\n        return done(e);\n      }\n    }\n    var valid;\n    try {\n      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);\n    } catch (e) {\n      return done(e);\n    }\n    if (!valid) {\n      return done(new JsonWebTokenError('invalid signature'));\n    }\n    var payload = decodedToken.payload;\n    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\n      if (typeof payload.nbf !== 'number') {\n        return done(new JsonWebTokenError('invalid nbf value'));\n      }\n      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\n      }\n    }\n    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\n      if (typeof payload.exp !== 'number') {\n        return done(new JsonWebTokenError('invalid exp value'));\n      }\n      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\n      }\n    }\n    if (options.audience) {\n      var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n      var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n      var match = target.some(function (targetAudience) {\n        return audiences.some(function (audience) {\n          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\n        });\n      });\n      if (!match) {\n        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\n      }\n    }\n    if (options.issuer) {\n      var invalid_issuer = typeof options.issuer === 'string' && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;\n      if (invalid_issuer) {\n        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\n      }\n    }\n    if (options.subject) {\n      if (payload.sub !== options.subject) {\n        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\n      }\n    }\n    if (options.jwtid) {\n      if (payload.jti !== options.jwtid) {\n        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\n      }\n    }\n    if (options.nonce) {\n      if (payload.nonce !== options.nonce) {\n        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));\n      }\n    }\n    if (options.maxAge) {\n      if (typeof payload.iat !== 'number') {\n        return done(new JsonWebTokenError('iat required when maxAge is specified'));\n      }\n      var maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n      if (typeof maxAgeTimestamp === 'undefined') {\n        return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n      }\n      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\n      }\n    }\n    if (options.complete === true) {\n      var signature = decodedToken.signature;\n      return done(null, {\n        header: header,\n        payload: payload,\n        signature: signature\n      });\n    }\n    return done(null, payload);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}